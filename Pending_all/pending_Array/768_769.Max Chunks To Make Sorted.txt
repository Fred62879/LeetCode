## Specification
Given an array arr that is a permutation of [0, 1, ..., arr.length - 1], we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array. What is the most number of chunks we could have made?

Example 1:
Input: arr = [4,3,2,1,0]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.
For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.

Example 2:
Input: arr = [1,0,2,3,4]
Output: 4
Explanation:
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.

Note:
arr will have length in range [1, 10].
arr[i] will be a permutation of [0, 1, ..., arr.length - 1].


## Testcases
[1,2,0,3]
[5,3,4,8,6,7,1,0,2]
[1,0,2,8,6,7,5,3,4]
[1,0,2,3,4]
[0,2,1]
[0]
[0,1]

[0,2,1,5,3,4,7,6,8]
[1,4,3,6,0,7,8,2,5]


[4,2,2,1,1]


## Ideas
(3) Maintain stack to record all local peak, the final amount of which is the answer.

(1.1) Instead of go thru the whole array one by one, at entry i, if left max > right min, then directly jump to where rightmin is attained.

(1) At a particular entry (i), if we can cut after it, it must be true that the largest so far ([0,i]) will be <= the smallest from i onward (i, n-1).


## Code
// (3) stack_others
class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        stack<int> cut; cut.push(arr[0]);
        for (int i = 1, curmax = arr[0]; i < arr.size(); i++) {
            while (!cut.empty() && cut.top() > arr[i]) cut.pop();
            curmax = max(curmax, arr[i]);
            cut.push(curmax);
        }
        return cut.size();
    }
};

// (2) others_only for 769
class Solution {
    public int maxChunksToSorted(int[] arr) {
        int ans = 0, max = 0;
        for (int i = 0; i < arr.length; ++i) {
            max = Math.max(max, arr[i]);
            if (max == i) ans++;
        }
        return ans;
    }
}

// (1.1)
class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        int n = arr.size(), xid = 0, nid = n - 1, ans = 0;
        vector<int> loclmx(n, 0), loclmn(n, n-1);
        for (int i = 1; i < n; i++) {
            if (arr[xid] < arr[i]) xid = i;
            loclmx[i] = xid; // max 0~cur (inclusive)
            loclmn[n - 1 - i] = nid; // min cur(exlusive)~n
            if (arr[nid] > arr[n - 1- i]) nid = n - 1 - i;
        }
        for (int i = 0; i < n; i++) { // whether cut after i
            if (arr[loclmx[i]] <= arr[loclmn[i]] || i == n - 1) ans++;
            else i = loclmn[i] - 1;
        }
        return ans;
    }
};

// (1) indep
class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        int n = arr.size(), mx = arr[0], mn = INT_MAX, ans = 0;
        vector<int> loclmx(n, 0), loclmn(n, n-1);
        for (int i = 0; i < n; i++) {
            if (mx < arr[i]) mx = arr[i];
            loclmx[i] = mx; // max 0~cur (inclusive)
            loclmn[n - 1 - i] = mn; // min cur(exlusive)~n
            if (mn > arr[n - 1- i]) mn = arr[n - 1 - i];
        }
        for (int i = 0; i < n; i++) // whether cut after i
            if (loclmx[i] <= loclmn[i]) ans++;
        return ans;
    }
};
