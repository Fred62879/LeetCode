## Specification
This problem is the same as Minimize Malware Spread, with the differences indicated below:

When we remove one node from the [initial] list, we completely remove it and any connections from this node to any other node.

Example 1:
Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0

Example 2:
Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
Output: 1

Example 3:
Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
Output: 1

Note:
1 < graph.length = graph[0].length <= 300
0 <= graph[i][j] == graph[j][i] <= 1
graph[i][i] = 1
1 <= initial.length < graph.length
0 <= initial[i] < graph.length



## Testcases
[[1,1,1,1,1,1,0],[1,1,0,0,0,0,0],[1,0,1,0,0,0,0],[1,0,0,1,0,0,0],[1,0,0,0,1,0,1],[1,0,0,0,0,1,0],[0,0,0,0,1,0,1]]
[1,3]



## Ideas
It is notable that we can only remove from the initial list, otherwise, the answer for the above testcase should be 0.

# (IV) Tarjan's algr
https://leetcode.com/problems/minimize-malware-spread-ii/discuss/199059/Real-O(N2)-Solution-base-on-Tarjan's-algorithm

# (III) BFS
https://leetcode.com/problems/minimize-malware-spread-ii/discuss/217529/c%2B%2B-solution-bfs

# (II) DUS
https://leetcode.com/problems/minimize-malware-spread-ii/discuss/184334/Simple-Union-Find-and-reuse-code-from-Leetcode-924

# (I) DFS
Actually it can be found that for nodes linked with no infected nodes, we can simply bypass them and for those which are reachable by more than one init infct nodes (path from init infct node to target node must not contain any other init infct nodes), they cannot be rescued removing only one from initial. Thus, only those reachable by exactly one node shall be of our concern. And the one in initial which corresponds to the largest # of this type of node shall be the answer.

Concise - https://leetcode.com/problems/minimize-malware-spread-ii/discuss/240299/C%2B%2B-DFS.-Short.-Beats-100



## Code
# (IV) Tarjan's algr
// others_fastest
struct NodeInfo {
    bool malware = false;
    int netid = -1;
    vector<pair<int, int>> subnets;
    int parent = -1, depth = -1, low = -1;
};

class Solution {
public:
    vector<vector<int>> * m_graph;
    vector<pair<int, int>> m_networks; // <nodes in network, malwares in network>
    vector<NodeInfo> m_nodes;
    
    pair<int, int> dfs(int i, int d, int netid) {
        m_nodes[i].depth = d;
        m_nodes[i].low = d;
        m_nodes[i].netid = netid;
        
        pair<int, int> scaned(1, m_nodes[i].malware ? 1 : 0);
        
        for (int j = 0; j < m_graph->size(); ++j) if (i != j && (*m_graph)[i][j]) {
            if (m_nodes[j].depth < 0) {
                m_nodes[j].parent = i;
                auto x = dfs(j, d + 1, netid);
                if (m_nodes[j].low >= m_nodes[i].depth)
                    m_nodes[i].subnets.push_back(x);
                m_nodes[i].low = std::min(m_nodes[i].low, m_nodes[j].low);
                
                scaned.first += x.first;
                scaned.second += x.second;
                
            } else if (j != m_nodes[i].parent) {
                m_nodes[i].low = std::min(m_nodes[i].low, m_nodes[j].depth);
            }
        }
        if (m_nodes[i].parent == -1 && m_nodes[i].subnets.size())
            m_nodes[i].subnets.pop_back();
        return scaned;
    }
    
    int saves(NodeInfo & n) {
        if (m_networks[n.netid].second == 0) return 0;
        
        pair<int, int> lastSubnet = m_networks[n.netid];
        lastSubnet.first -= 1;
        lastSubnet.second -= n.malware ? 1 : 0;
        
        int count = 0;
        for (auto & subnet : n.subnets) {
            if (subnet.second == 0)
                count += subnet.first;
            lastSubnet.first -= subnet.first;
            lastSubnet.second -= subnet.second;
        }
        if (lastSubnet.second == 0)
            count += lastSubnet.first;
        return count;
    }
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        m_graph = &graph;
        m_networks.clear();
        m_nodes.clear();
        m_nodes.resize(graph.size());
        
        for (int i : initial) m_nodes[i].malware = true;
        for (int i = 0; i < m_nodes.size(); ++i) if (m_nodes[i].netid == -1) {
            auto x = dfs(i, 0, m_networks.size());
            m_networks.push_back(x);
        }
        int maxSaves = -1, maxIdx = -1;
        for (int i = 0; i < m_nodes.size(); ++i) if (m_nodes[i].malware) {
            int s = saves(m_nodes[i]);
            if (s > maxSaves) maxSaves = s, maxIdx = i;
        }
        return maxIdx;
    }
};


# (III) BFS


# (II) DUS


# (I) DFS
// derived
class Solution {
public:
    vector<vector<int>> srcs;
        
    void spread(int src, int p, vector<vector<int>>& g) {
        for (int i = 0; i < g.size(); i++)
            if (g[p][i] && g[i][i] != -1 && (srcs[i].empty() || srcs[i].back() != src) )
                srcs[i].push_back(src), spread(src, i, g);
    }
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size(), m = initial.size(), sml = INT_MAX;
        srcs.assign(n, vector<int>());
        // spread malware from each initially infected one
        for (int i : initial) {
            graph[i][i] = -1; // mark as init infected
            sml = min(sml, i); // find smallest one, possible result
        }
        for (int i : initial) spread(i, i, graph);
        
        // evaluate each init
        int ans = INT_MAX, mxct = INT_MIN;
        unordered_map<int, int> candi;
        for (int i = 0; i < n; i++) if (srcs[i].size() == 1) {
            int init = srcs[i][0];
            if (candi.count(init)) candi[init]++;
            else candi[init] = 1;
            // update answer
            if (candi[init] >= mxct) {
                ans = candi[init] == mxct ? min(ans, init) : init;
                mxct = candi[init];
            }
        }
        return ans == INT_MAX ? sml : ans;
    }
};
