class Solution  {
public:
	int getMaxRepetitions(string s1, int n1, string s2, int n2)  {

		// Let (pass2, idx2) mean that we cover a string s2 for pass2 times,
		// and reach idx2-th character.
		// (pass2s, idx2s) stores the that, for pass1-th pass of s1,
		// we cover a string s2 for pass2s[pass1] times,
		// and reach idx2s[pass1]-th character.

		vector<int> pass2s(s2.size() + 1u, -1);
		vector<int> idx2s(s2.size() + 1u, -1);
		pass2s[0] = 0;
		idx2s[0] = 0; // at the beginning, we are at (0, 0)
		// we will let all elements in idx2s be different
		// according to pigeonhole principle,
		// we only need s2.size()+1 to find two elements 
		// that are identical to each other.

		int pass2 = 0;
		int idx2 = 0;

		for (int pass1 = 1; pass1 <= n1; ++pass1) {
			// Due to pigeonhole principle
			// we are sure to break within O(s2.size()) iterations

			for (int idx1 = 0; idx1 < s1.size(); ++idx1) { // scan s1
				if (s2[idx2] == s1[idx1]) {
					++idx2;
					if (idx2 == s2.size()) {
						idx2 = 0;
						++pass2;
					}
				}
			}
			pass2s[pass1] = pass2;
			idx2s[pass1] = idx2;

			// try to find the repetitive part
			for (int prevPass1 = 0; prevPass1 < pass1; ++prevPass1) {
				if (idx2s[prevPass1] == idx2) {
					// prevRepeat1 and pass1 share the same idx2,
					// repetitive part is found

					int repeatCount = (n1 - prevPass1) / (pass1 - prevPass1);
					int remainPass1count = (n1 - prevPass1) % (pass1 - prevPass1);

					int prefixPass2Num = pass2s[prevPass1]; // prefix part
					int repetitivePass2Num = repeatCount * (pass2s[pass1] - pass2s[prevPass1]); // repetitive part
					int suffixPass2Num = pass2s[prevPass1 + remainPass1count] - pass2s[prevPass1];
					
					int overallPass2Num = prefixPass2Num + repetitivePass2Num + suffixPass2Num;
					return overallPass2Num / n2;
				}
			}
		}

		// no repeative part found
		return pass2s[n1] / n2;
	}
};