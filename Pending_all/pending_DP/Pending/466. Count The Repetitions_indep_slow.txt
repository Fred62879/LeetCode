"acb"

4

"ab"

2

"baba"
11
"baab"
1

"ecbafedcba"
4
"abcdef"
1

"phqghumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjprepggxrpnrvystmwcysyycqpevikeffmznimkkasvwsrenzkycxf"
100
"xtlsgypsfa"
1
	  10l 	15x  21s		     44t
"phqghumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjprepggxrpnrvystmwcysyycqpevikeffmznimkkasvwsrenzkycxf"
100000
"xtlsgypsfadpooefxzbcoejuvpvaboygpoeylfpbnpljvrvipyamyehwqnqrqpmxujjloovaowuxwhmsncbxcoksfzkvatxdknly"
1

"aaa"
20
"aaaaa"
1

"aahumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjprepggxrpnrvystmwcysyycqpevikeffmznimkkasvwsrenazkycxf"
1000000
"aac"
1000000

/* 
for this last test case, it is found that apart from the first operation which starts at 15 in s1, 
all other operations start at 98 in s1, similar case holds for:
"bdefb"
10
"bdef"
1

// naive - TLE
class Solution {
    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
        char[] sc1 = s1.toCharArray(), sc2 = s2.toCharArray();
        int prevNo = 0, res = 0, prevs1 = 0, curNo = 0;
        for (int i = 1, cur = 0; i <= n1; i++) {
            for (int j = 0; j < s1.length(); j++) {
                if (sc1[j] != sc2[cur]) continue;
                if (++cur == s2.length()) { 
                    if (curNo++ == 0) prevs1 = i;
                    cur = 0; 
                }
            }
        }
        return curNo / n2;
    }
}

// improve
// it can be assured that total # of s2-match in s1 over n2 is the ans 
// we basically trying to detect a loop, that is if a new first-char-match occurs at the same Loc
// in s1 as that of the very first first-char-match, it starts a loop
class Solution {
    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
        int[] ref = new int[n1 + 1];
        // ArrayList<Integer> test = new ArrayList<Integer>();
        HashMap<Integer, Integer> test = new HashMap<Integer, Integer>();
	    // curNo is accumulated # of s2-match
        // st is id of char in s1 being the very first first-char-match
        // ed is id of s1 where last char in s2 is matched
	    // cur is id of last char matched in s2
        int curNo = 0, st = -1, ed = 0;
        for (int i = 1, cur = 0, curSt = -1; i <= n1; i++, curSt = -1) {
            for (int j = 0; j < s1.length(); j++) {
                if (s1.charAt(j) != s2.charAt(cur)) continue; 
                if (cur == 0) { if (curNo == 0) st = j; curSt = j; test.put(i, curSt); } // test.add(curSt); }
                if (i != 1 && curSt == st) break; // first loop ended
                if (++cur == s2.length()) { cur = 0; curNo++; ed = i; }   
            }
            if (st == -1) return 0;
            ref[i] = curNo;
            if (i != 1 && curSt == st) {
                int r = i == ed ? (n1-1) % (ed-1) : n1 % ed; // # of s1 left
                int fold = i == ed ? (n1-1) / (ed-1) : n1 / ed;;
                int residu = r == 0 ? 0 : ref[r];
                return (curNo * fold + residu) / n2;
            }
        }
        // for (int i = 1; i < test.size(); i++)
        //    if (test.get(i) == 15) return i;
        for (int i = 2; i < 10000; i++)
            if (test.get(i) != null) return test.get(i);
        return curNo / n2;
    }
}