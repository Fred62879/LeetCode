## Specification
Similar: LT62, 70, 509, 639

A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1; 'B' -> 2; ...; 'Z' -> 26. Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:
Input: "12"
Output: 2
Explanation: It could be decoded as "AB" (1 2) or "L" (12).

Example 2:
Input: "226"
Output: 3
Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).



## Testcases
"101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010"
"0"
"100"


## Ideas
# (I) DP_bottom-up
// others
Traverse from end to front. And dp[i] would record that s[i:n] can be encoded. This enables simpler processing of '0' which once present in, say i, would nullify dp[i]

// indep
Let dp[i] denotes the # of ways s[0:i] can be decoded. Take s = "1226" for instance. dp[0] = 1 is initialized. And as we evaluating 2, we can either append it independently to the dp[0] or append it together with its previous digit which is 1. For the second case, more formally, as we reach the 2nd 2, we need to refer to dp[0] (dp[i-2]) as we are appending digit 2 + digit 1 to all decoded chars for s[0:0].



## Code
# (I) DP_bottom-up
// others_concise
class Solution {
public:
    int numDecodings(string s) {
        int p = 1, pp, n = s.size();
        for(int i=n-1;i>=0;i--) {
            int cur = s[i]=='0' ? 0 : p;
            if(i<n-1 && (s[i]=='1'||s[i]=='2'&&s[i+1]<'7')) cur+=pp;
            pp = p;
            p = cur;
        }
        return s.empty()? 0 : p;   
    }
};

// indep
class Solution {
public:
    int numDecodings(string s) {
        if (s[0] == '0') return 0;
        int n = s.size(), q = 1e9+7;
        // dp[i], # of ways s[0:i] can be decoded
        vector<long> dp(n, 0);
        dp[0] = 1;
        for (int i = 1; i < n; i++) {
            if (s[i] == '0') {
                if (s[i-1] > '2' || s[i-1] == '0') return 0;
                dp[i] = i > 1 ? dp[i - 2] : 1;
            } else {
                if (s[i-1] == '1' || (s[i-1] == '2' && s[i] < '7'))
                    dp[i] = i > 1 ? dp[i - 2] : 1;
                dp[i] = (dp[i] + dp[i - 1] + q) % q;
            }
        }
        // for (int i = 0; i < n; i++)
            // cout << i << ": " << dp[i] << endl;
        return dp[n - 1];
    }
};
