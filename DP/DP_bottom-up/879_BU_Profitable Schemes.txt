## Specification
There are G people in a gang, and a list of various crimes they could commit. The
i-th crime generates a profit[i] and requires group[i] gang members to participate.
If a gang member participates in one crime, that member can't participate in
another crime.

Let's call a profitable scheme any subset of these crimes that generates at least 
P profit, and the total number of gang members participating in that subset of 
crimes is at most G. How many schemes can be chosen?  Since the answer may be very 
large, return it modulo 10^9 + 7.

Example 1:
Input: G = 5, P = 3, group = [2,2], profit = [2,3]
Output: 2
Explanation: 
To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1.
In total, there are 2 schemes.

Example 2:
Input: G = 10, P = 5, group = [2,3,5], profit = [6,7,8]
Output: 7
Explanation: 
To make a profit of at least 5, the gang could commit any crimes, as long as they commit one.
There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).

Note:
1 <= G <= 100
0 <= P <= 100
1 <= group[i] <= 100
0 <= profit[i] <= 100
1 <= group.length = profit.length <= 100


## Testcases
10
5
[2,3,5]
[6,7,8]

100
100
[2,5,36,2,5,5,14,1,12,1,14,15,1,1,27,13,6,59,6,1,7,1,2,7,6,1,6,1,3,1,2,11,3,39,21,20,1,27,26,22,11,17,3,2,4,5,6,18,4,14,1,1,1,3,12,9,7,3,16,5,1,19,4,8,6,3,2,7,3,5,12,6,15,2,11,12,12,21,5,1,13,2,29,38,10,17,1,14,1,62,7,1,14,6,4,16,6,4,32,48]
[21,4,9,12,5,8,8,5,14,18,43,24,3,0,20,9,0,24,4,0,0,7,3,13,6,5,19,6,3,14,9,5,5,6,4,7,20,2,13,0,1,19,4,0,11,9,6,15,15,7,1,25,17,4,4,3,43,46,82,15,12,4,1,8,24,3,15,3,6,3,0,8,10,8,10,1,21,13,10,28,11,27,17,1,13,10,11,4,36,26,4,2,2,2,10,0,11,5,22,6]


## Ideas
# (II) DP_bottom-up
(ii) 2D_others
https://leetcode.com/problems/profitable-schemes/discuss/154617/C%2B%2BJavaPython-DP

(i) 3D_others
// induction
The 3D array records the number of schemes generated by <= j people profiting >= k. This can be easily proved by induction. 

For initiation, since the first two cases (do not take cur & start at cur) records already
profit no less than k (if condition >= 0), so there is no way to claim this 3D array record
the ... profit exactly some value.

For the maintenance, suppose that plan i profit 8 and current requirement is >= 10. Then,
given the schemes terminated at 7, we access that profit 2 which records number of schemes
generated by <= j people profiting at least 2 using i - 1 plans.

// overall
The notable point is that the for loops do not need to follow any specific order, any of the three levels can be the outer/middle/inner loop. And the key idea is similar to knapsack which highlights the decision making process at each element - either take the current element or not.
If do not take current, very simple just the same as previous (g and p hold, st decrement). When taking current, since current profit can decrease the profit requirements, we can simply trace back to the position where profit requirement is exactly the same as current requirement decreased.

# (I) DP_top-down_indep



## Code
# (II) DP_bottom-up
// 2D others
class Solution {
public:
    int profitableSchemes(int G, int P, vector<int> group, vector<int> profit) {
	// int dp[P + 1][G + 1];
	// memset(dp, 0, sizeof(dp));
        vector<vector<int>> dp(P + 1, vector<int>(G + 1, 0));
        dp[0][0] = 1;
        int res = 0, mod = 1e9 + 7;
        for (int k = 0; k < group.size(); k++) {
            int g = group[k], p = profit[k];
            for (int i = P; i >= 0; i--)
                for (int j = G - g; j >= 0; j--)
                    dp[min(i + p, P)][j + g] = (dp[min(i + p, P)][j + g] + dp[i][j]) % mod;
        }
        for (int x: dp[P]) res = (res + x) % mod;
        return res;
    }
};

// 3D others
const int modulo=1000000007;
class Solution {
public:
    int profitableSchemes(int G, int P, vector<int>& group, vector<int>& profit) {
        int dp[101][101][101],n=group.size();
        memset(dp,0,sizeof(dp));
        //dp[x][g][p] means in the first x crimes, with g people rest, still need to create p profits
        //dp[-1][G][P]=1;
        dp[0][G][P]=1;
        for (int i=0;i<n;++i){
            for (int g=G;g>=0;--g)
                for (int p=P;p>=0;--p)
                    if (dp[i][g][p]>0){
                        dp[i+1][g][p]+=dp[i][g][p];
                        dp[i+1][g][p]%=modulo;
                        if (g<group[i]) continue;
                        dp[i+1][g-group[i]][max(0,p-profit[i])]+=dp[i][g][p];
                        dp[i+1][g-group[i]][max(0,p-profit[i])]%=modulo;
                    }
        }
        int ans=0;
        for (int g=G;g>=0;--g) ans=(ans+dp[n][g][0])%modulo;
        return ans;
    }
};

// derived
class Solution {
public:
    int profitableSchemes(int G, int P, vector<int>& group, vector<int>& profit) {
        int n = group.size(), q = 1e9 + 7;
        // dp[i][j][k] - # of schemes using at most j people profiting at least k using plans 0~i
        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(G+1, vector<int>(P+1, 0)));
        for (int i = 1; i <= n; i++) {         // till i - 1
            for (int j = 1; j <= G; j++) {     // max people available
                int gleft = j - group[i - 1];  // # of people left after taking cur
                for (int k = 0; k <= P; k++) { // min profit required
                    dp[i][j][k] += dp[i - 1][j][k] % q;    // (1) do not take current
                    int pleft = max(0, k - profit[i - 1]); // profit still needed after taking cur
                    if (gleft >= 0) {
                        // (2) start from cur
                        dp[i][j][k] = (dp[i][j][k] + (pleft == 0 ? 1 : 0)) % q;
                        // (3) append cur to proper previous scheme
                        dp[i][j][k] += dp[i-1][gleft][pleft] % q;
                    }
                    dp[i][j][k] %= q;
                }
            }
        }
        return dp[n][G][P];
    }
};

// indep
class Solution {
public:
    int profitableSchemes(int G, int P, vector<int>& group, vector<int>& profit) {
        int n = group.size(), q = 1e9 + 7;
        // dp[i][j][k], # of schemes profting >= i requiring <= j people using plans 0~k
        int dp[P + 1][G + 1][n];
        for (int i = 0; i <= P; i++) for (int j = 0; j <= G; j++)
            memset(dp[i][j], 0, sizeof(dp[i][j]));
        // ini
        for (int p = 0; p <= profit[0] && p <= P; p++)
            for (int g = G; g >= group[0]; g--) dp[p][g][0] = 1;
        // bottom-up
        for (int p = 0; p <= P; p++) {
            for (int g = 1; g <= G; g++) {
                for (int st = 1; st < n; st++) {
                    int bypass = dp[p][g][st - 1], pick = 0;
                    if (g >= group[st]) { // able to select current plan - sufficient people
                        int lpft = p - profit[st]; // left profit - profit still needed
                        pick = (dp[max(0, lpft)][g - group[st]][st - 1] + (lpft <= 0 ? 1 : 0)) % q;
                    }
                    dp[p][g][st] = (pick + bypass) % q;
                }
            }
        }
        return dp[P][G][n - 1];
    }
};
