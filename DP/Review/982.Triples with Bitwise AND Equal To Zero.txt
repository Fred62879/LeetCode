## Specification
Given an array of integers A, find the number of triples of indices (i, j, k) such that:
0 <= i < A.length
0 <= j < A.length
0 <= k < A.length
A[i] & A[j] & A[k] == 0, where & represents the bitwise-AND operator.

Example 1:
Input: [2,1,3]
Output: 12
Explanation: We could choose the following i, j, k triples:
(i=0, j=0, k=1) : 2 & 2 & 1
(i=0, j=1, k=0) : 2 & 1 & 2
(i=0, j=1, k=1) : 2 & 1 & 1
(i=0, j=1, k=2) : 2 & 1 & 3
(i=0, j=2, k=1) : 2 & 3 & 1
(i=1, j=0, k=0) : 1 & 2 & 2
(i=1, j=0, k=1) : 1 & 2 & 1
(i=1, j=0, k=2) : 1 & 2 & 3
(i=1, j=1, k=0) : 1 & 1 & 2
(i=1, j=2, k=0) : 1 & 3 & 2
(i=2, j=0, k=1) : 3 & 2 & 1
(i=2, j=1, k=0) : 3 & 1 & 2

Note:
1 <= A.length <= 1000
0 <= A[i] < 2^16


## Testcases
[7,9,10,3,1,4,6,8,7,2]



## Ideas
# (2) DP
https://leetcode.com/problems/triples-with-bitwise-and-equal-to-zero/discuss/226721/Java-DP-O(3-*-216-*-n)-time-O(216)-space


# (1) Naive
// optimized
For two ints say, 10100 and 01100, since digits 3 and 1 & up as 1, there is actually no need to check preceding ints of 01100 including 01101, 01110, and.... And we simply decrment j with (01101 & 01110) (notice the minus one in code is to leave space for j++).

In detail, imagine we have current A[i] being 10100, and when we increment j to 00100, result is not 0. We thus update j to 01000. As we proceed, when we reach 01100, we again have a non-zero &. In this case, as we know the & operation now will render a number where the msd 1 is at the digit where 1 appears in both A[i] and j.

11100      11100                    10110       10110       10110       10110
01000  ->  10000                    01001  ->   01010   ->  01100   ->  11000

This is the case, as if we have certain 1 to the left of the current problematic digit, for instance, when A[i] being 11100, then as we update j to 01000, we increment immediately and there is no opportunity to reach 01100 at all. Similarly, there shall be no digit to the right of current problematic digit. For instance if A[i] equals 10110, then as we reach 01010 from 01001, we update immediately and still reach 01100.



// derived
For each pair of ints from original array, store their pair-wise & product and then for each value in original array, iterate thru all possible ints to find those that that & up to 0.

// indep
First record the # of all possible numbers generated by all pair-wise & of the given ints. Then, appending the given ints to these generated numbers and count.



## Code
# (2) DP_bottom-up
// others_genric


# (1) naive
// derived_244ms / optimized_28ms
class Solution {
public:
    int countTriplets(vector<int>& A) {
        int n = A.size(), m = 1 << 16, ans = 0;
        // dp[i], # of int pairs (order-sensitive) & up to i
        int dp[m]; memset(dp, 0, sizeof(dp));
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++) dp[A[i] & A[j]]++;
        
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if (!(A[i] & j)) ans += dp[j];
		else j += (A[i] & j) - 1; // **** OPTIMIZED ****
        return ans;
    }
};

// indep_420ms
class Solution {
public:
    int countTriplets(vector<int>& A) {
        int n = A.size(), m = 0, q = 1e9 + 7;
        for (int i : A) m = max(m, i);
        
        long ans = 0;
        // dp[i], # of int pairs (order-sensitive) & up to i
        int dp[m + 1]; memset(dp, 0, sizeof(dp));
        for (int i = 0; i < n; i++)
            for (int j = i; j < n; j++) dp[A[i] & A[j]] += (i == j ? 1 : 2) % q;
        
        for (int i = 0; i <= m; i++) // for each i generated from x & x
            for (int j : A) // append j
                if (dp[i] && !(i & j))
                    ans = (ans + dp[i]) % q; // and count
        return ans;
    }
};
