The resulting rect must be a block defined by [sr...tr][sc...tc], e.g.
[[1,0,2,-1,3],
 [4,2,-3,1,0],
 [2,1,4,2,-3]]
8

we first check rects that terminate at last row. Under this, we serially
check rect that start from row 2,1,0. For rect start from row 2, update
cur is the same as initialize it. As for row 1, we perform column-wise
addition, i.e. 4+2, 2+1, -3+4, 1+2, 0+(-3). Then we check rect terminates
at each column


// naive 
class Solution {
    public int maxSumSubmatrix(int[][] m, int k) {
        int r = m.length, c = m[0].length, max = Integer.MIN_VALUE;
        for (int tr = r - 1; tr >= 0; tr--) {
            int[] cur = new int[c]; // cur[j] = m[tr][j] + ... + m[sr][j]
            for (int sr = tr; sr >= 0; sr--) {
                // evaluate rect starts at row sr and terminates at row tr
                for (int j = c - 1; j >= 0; j--) cur[j] += m[sr][j]; // update
                int[] col = Arrays.copyOf(cur, cur.length); // deep copy

		// column check
                for (int j = c - 2; j >= 0; j--) col[j] += col[j + 1];
                for (int tc = c - 1; tc >= 0; tc--) {
                    int offset = tc == c - 1 ? 0 : cur[tc + 1];
                    // evaluate rect terminate at col tc starts at col sc
                    // col[j] = col[sc] + ... + col[tc] - realized by
		    // minusing offset
                    for (int sc = tc; sc >= 0; sc--) {
                        int area = col[sc] -= offset;
                        if (area == k) return k;
                        if (area > max && area < k) max = Math.max(area, max);
                    }
                }
                
            }
        }
        return max;
    }
}