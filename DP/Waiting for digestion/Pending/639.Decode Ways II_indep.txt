**** Specification ****
A message containing letters from A-Z is being encoded to numbers using the following mapping way:
'A' -> 1
'B' -> 2
...
'Z' -> 26
Beyond that, now the encoded string can also contain the character '*', which can be treated as 
one of the numbers from 1 to 9. Given the encoded message containing digits and the character '*',
return the total number of ways to decode it. Also, since the answer may be very large, you 
should return the output mod 109 + 7.

Example 1:
Input: "*"
Output: 9
Explanation: The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".

Example 2:
Input: "1*"
Output: 9 + 9 = 18
Note:
The length of the input string will fit in range [1, 105]. The input string will only contain the
character '*' and digits '0' - '9'.


**** Idea ****
    1   2   *   2   *   4   *   *
1   1   1
2       1   6
*           9   2
2               1   6
*                   9   2
4                       1   0
*                           9   15
*                               9


**** Code ****
class Solution {
    public int numDecodings(String s) {
        int sl = s.length();
        long[] ref = new long[sl*2 - 1];
        char[] sc = s.toCharArray();
        long st = 1000000007;
        // construct reference array
        for (int i = 0; i < sl*2 - 1; i += 2) {
            ref[i] = sc[i/2] == '*' ? 9 : (sc[i/2] == '0' ? 0 : 1);
            if (i/2 + 1 == sl) break;
            // next is *: if cur is also *, then gives 15; otherwise if cur >2/=0, gives 0; o 9/6
            if (sc[i/2 + 1] == '*') 
                ref[i + 1] = sc[i/2] == '*' ? 15 : (sc[i/2] > '2' || sc[i/2] == '0' ? 0 : sc[i/2] == '1' ? 9 : 6);
            // next is #, cur is *: if next > 6, gives 1; else 2
            else if (sc[i/2] == '*') ref[i + 1] = sc[i/2 + 1] > '6' ? 1 : 2;
            // next is #, cur is #: if cur >2/=0 gives 0; oif cur = 1 OR next <= 6 gives 1; o 0
            else ref[i + 1] = sc[i/2] > '2' || sc[i/2] == '0' ? 0 : (sc[i/2] == '1' || sc[i/2 + 1] <= '6' ? 1 : 0);
        }
        // go thru ref
        for (int i = sl*2 - 4; i >= 0; i -= 2) {
            if (i + 1 + 3 < sl*2 - 1) ref[i + 1] = (ref[i + 1] * ref[i + 1 + 3]) % st;
            ref[i] = (ref[i] * ref[i + 2] + ref[i + 1]) % st;
        }
        return (int)ref[0];
    }
}