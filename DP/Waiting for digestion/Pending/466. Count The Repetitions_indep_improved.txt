/*
s1: abbc abbc abbc abbc
s2: abcb

we construct dp as:
id 0(a)  1(b)   2(c)
   0     1/2    3

We basically store the location of each char in s1. This saves
the time to go thru each char in s1 to find the match char.

// curNo is accumulated # of matched s2 so far
// curSt is char id in current s1 where 1st char in s2 is matched
// st is char id in 1st s1 where 1st char in s2 is matched
// curS1 is char id in current s1 where former char in s2 is matched
// ed is s1 id where final char in s2 is matched
// if proceed = 1, ith s1 check finish, proceed to next s1
// s2st is char id in s2 where check should start

*/

class Solution {
    
    int proceed = 0;
    int[] ref;
    
    private int val(int i, int ed, int n1, int n2, int curNo) {
        int r = i == ed ? (n1-1) % (ed-1) : n1 % ed;
        int fold = i == ed ? (n1-1) / (ed-1) : n1 / ed;;
        int residu = r == 0 ? 0 : ref[r];
        return (curNo * fold + residu) / n2;
    }
    
    // find char id (curS1) in cur s1 corresponds to cur char in s2
    private int next(ArrayList<Integer> cur, int curS1) {
        for (int k = 0; k < cur.size(); k++) {
            if (cur.get(k) > curS1) return cur.get(k); 
            else if (k == cur.size()-1) proceed = 1;
        }
        return curS1;
    }
    
    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
        ref = new int[n1 + 1];
        ArrayList<Integer>[] dp = new ArrayList[26];
        for (int i = 0; i < 26; i++) dp[i] = new ArrayList<Integer>();
        // store location for each char in s1
        for (int i = 0; i < s1.length(); i++) dp[s1.charAt(i)-'a'].add(i);
        
        int curNo = 0, curSt = -1, st = -1, curS1 = -1, ed = 0, s2st = -1;
        for (int i = 1; i <= n1; i++, curSt = -1, proceed = 0, curS1 = -1) { // iterate thru s1
            for (int j = s2st+1; j < s2.length(); j++) { // check char in s2 under cur s1
                if (dp[s2.charAt(j)-'a'].isEmpty()) return 0; // if s1 does not contain s2[j]
                curS1 = next(dp[s2.charAt(j)-'a'], curS1);    // update curS1
                if (proceed == 1) { s2st = j - 1; break; }        // all s2[j] in cur s1 are checked, proceed to next s1
                if (j == 0) { if (curNo == 0) st = curS1; curSt = curS1; }
                
                // first loop finised, turn to calculate ans
                if (i != 1 && curSt == st) return val(i, ed, n1, n2, curNo);
                if (j == s2.length()-1) { curNo++; ed = i; j = -1; } // cur s2 fully matched, re-initialize j
                if (curS1 == s1.length()-1) { s2st = j; break; }     // if reach end in cur s1, proceed to next s1
            }
            if (st == -1) return 0;
            ref[i] = curNo;
        }
        return curNo / n2;
    }
}

// it is discovered that the above method did not make use of loop detection
// but calculate thru, i.e. result is returned in the last line (return curNo/n2;)
// as in:
"bdefb"
10
"bdef"
1
// loop may not start exactly at where the initial match occur. Therefore, loop is never
// detected if were to have the same start Loc as the first match

// further improved
class Solution {
    
    int proceed = 0;
    // e.g. st.get(i) = a -> there is a first-char-match at a[1]\th char of a[0]\th s1
    ArrayList<int[]> st = new ArrayList<int[]>();

    
    // cur 1st-char-match at curS1\th char of s1id\th s1, 
    private int val(int n1, int s1id, int curS1) {
        // check all prev char id in s1 where 1st-char-match occurs for loop detection
        int preface = -1, loop = 0; ArrayList<Integer> ref = new ArrayList<Integer>();
        for (int i = 0; i < st.size(); i++) if (st.get(i)[1] == curS1) preface = i;
        int[] res = {s1id, curS1}; st.add(res);
        if (preface == -1) return -1; // no loop
        
        // loop start at curS1\th char of stid\th s1 (curS1 = st.get(preface)[1])
        int stid = st.get(preface)[0], curid = 0, rowPreface;
        for (int i = preface; i < st.size(); i++) {
            if (st.get(i)[0] == s1id && st.get(i)[1] == curS1) loop = i;
            curid = st.get(i)[0]; // within loop, current match at curid\th s1
            if (curid-stid < ref.size()) ref.set(curid-stid, ref.get(curid-stid) + i - preface);
            else ref.add(i - preface);
        }
        // calculate ans; first check if preface-1\th match occurs at same s1 as preface\th match
        if (preface == 0) rowPreface = 0;
        else rowPreface = st.get(preface - 1)[0] == stid ? st.get(preface - 1)[0] - 1 : st.get(preface - 1)[0];
        int residue = (n1 - rowPreface) % (curid - stid);
        int left = residue == 0 ? 0 : ref.get(residue - 1);
        int fold = (n1 - rowPreface) / (curid - stid);
        return preface + (loop - preface) * fold + left;
    }
    
    // find char id (curS1) in cur s1 corresponds to cur char in s2
    private int next(ArrayList<Integer> cur, int curS1) {
        for (int k = 0; k < cur.size(); k++) {
            if (cur.get(k) > curS1) return cur.get(k); 
            else if (k == cur.size()-1) proceed = 1;
        }
        return curS1;
    }
    
    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
        ArrayList<Integer>[] dp = new ArrayList[26];
        for (int i = 0; i < 26; i++) dp[i] = new ArrayList<Integer>();
        for (int i = 0; i < s1.length(); i++) dp[s1.charAt(i)-'a'].add(i);   // store location for each char in s1
        
        int curNo = 0, curSt = -1, curS1 = -1, ed = 0, s2st = -1;
        for (int i = 1; i <= n1; i++, curSt = -1, proceed = 0, curS1 = -1) { // iterate thru s1
            for (int j = s2st+1; j < s2.length(); j++) {      // check char in s2 under cur s1
                if (dp[s2.charAt(j)-'a'].isEmpty()) return 0; // if s1 does not contain s2[j]
                curS1 = next(dp[s2.charAt(j)-'a'], curS1);    // update curS1
                if (proceed == 1) { s2st = j - 1; break; }    // all s2[j] in cur s1 are checked, proceed to next s1
                if (j == 0) {                                 // first char match for each s2
                    int v = val(n1, i, curS1);
                    if (v != -1) return v / n2;
                }
                if (j == s2.length()-1) { curNo++; ed = i; j = -1; } // cur s2 fully matched, re-initialize j
                if (curS1 == s1.length()-1) { s2st = j; break; }     // if reach end in cur s1, proceed to next s1
            }
        }
        return curNo / n2;
    }
}

/*
s1: abbc abbc abbc abbc
s2: abcb

we construct dp as:
id 0(a)  1(b)   2(c)
   0     1/2    3
   
// curNo is accumulated # of matched s2 so far
// curSt is char id in current s1 where 1st char in s2 is matched
// st is char id in 1st s1 where 1st char in s2 is matched
// curS1 is char id in current s1 where former char in s2 is matched
// ed is s1 id where final char in s2 is matched
// if proceed = 1, ith s1 check finish, proceed to next s1
// s2st is char id in s2 where check should start

*/

class Solution {
    
    // e.g. st.get(i) = a -> there is a first-char-match at a[1]\th char of a[0]\th s1
    ArrayList<int[]> ed = new ArrayList<int[]>();
    int proceed = 0;
    
    // cur 1st-char-match at curS1\th char of s1id\th s1, 
    private int val(int n1, int s1id, int curS1) {
        // check all prev char id in s1 where s2 fully matched
        int preface = -1;
        for (int i = 0; i < ed.size(); i++) if (ed.get(i)[1] == curS1) preface = i;
        int[] res = {s1id, curS1}; ed.add(res);
        if (preface == -1) return -1; // no loop
        int stid = ed.get(preface)[0], loop = ed.size()-1, curid = ed.get(loop)[0], left = 0;
        // calculate ans
        int residue = (n1 - stid) % (curid - stid);
        int fold = (n1 - stid) / (curid - stid);
        for (int i = preface + 1; i <= loop; i++)
            if (ed.get(i)[0] <= stid + residue) left++;
        return preface + 1 + (loop - preface) * fold + left;
    }
    
    // find char id (curS1) in cur s1 corresponds to cur char in s2
    private int next(ArrayList<Integer> cur, int curS1) {
        for (int k = 0; k < cur.size(); k++) {
            if (cur.get(k) > curS1) return cur.get(k); 
            else if (k == cur.size()-1) proceed = 1;
        }
        return curS1;
    }
    
    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
        ArrayList<Integer>[] dp = new ArrayList[26];
        for (int i = 0; i < 26; i++) dp[i] = new ArrayList<Integer>();
        for (int i = 0; i < s1.length(); i++) dp[s1.charAt(i)-'a'].add(i);   // store location for each char in s1
        
        int curNo = 0, curS1 = -1, s2st = -1;
        for (int i = 1; i <= n1; i++, proceed = 0, curS1 = -1) { // iterate thru s1
            for (int j = s2st+1; j < s2.length(); j++) {      // check char in s2 under cur s1
                if (dp[s2.charAt(j)-'a'].isEmpty()) return 0; // s1 does not contain s2[j]
                curS1 = next(dp[s2.charAt(j)-'a'], curS1);    // update curS1
                if (proceed == 1) { s2st = j - 1; break; }    // all s2[j] in cur s1 are checked, proceed to next s1
                if (j == s2.length()-1) {                     // cur s2 fully matched, re-initialize j and check loop
                    curNo++; j = -1;
                    int v = val(n1, i, curS1);
                    if (v != -1) return v / n2;
                } if (curS1 == s1.length()-1) { s2st = j; break; } // reach end in cur s1, proceed to next s1
            }
        }
        return curNo / n2;
    }
}