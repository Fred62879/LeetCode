## Specification
Similar to LT\312
Given several boxes with different colors represented by different positive numbers. You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k >= 1), remove them and get k*k points. Find the maximum points you can get.

Example 1:
Input:
[1,2,2,2,2,3,4,3,1]
Output:
23
Explanation:
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----> [1, 3, 3, 4, 3, 1] (3*3=9 points) 
----> [1, 3, 3, 3, 1] (1*1=1 points) 
----> [1, 1] (3*3=9 points) 
----> [] (2*2=4 points)
Note: The number of boxes n would not exceed 100.


## Ideas
# (3) indep_2nd visit
The base case is that we remove each element on its own regardless of identical boxes. To increase the result, we need to remove boxes identical in color together. We can think of it in this way, at the last removal, box(es) of one color are
removed. Therefore, we can simulate box of each color to be such last removal. And for each color, if there are x slots of boxes not immediately adjacent in the array, we check possibility for the comination of each. 

For instance, it we have x,x,x,3,3,3,x,x,x,3,3,x,x,x,3,x,x,x; then we check the result if the last removal is 3-3 & 2-3; 3-3 & 2-3 & 1-3; 2-3 & 1-3. Since that should be the last removal, the slots besides that or interclating that should be removed as a unit and can be recursively solved.

To implement this idea efficiently, we record mid as the max for the interclating sequence between two removal boxes and as we recurse, we update this part.

In the 2nd implementation, solve is not used to calculate the value of the subarray from lo to hi but instead take into account the previously accumulated mid. This is problematic as there can be many combinations of final-box-pop that include calculting the same subarray. If we insist use this implem, we have to define each touch uniquely, possibly using a 4D array, with an extra dimension redorcing the accumulated mid although this still may guarantee an absolute unique of each touch of the particular subarray.

If we use solve to calculate only the value of lo->hi there is no problem as this can be shared by all combinations entails it, each of which separately calculate the mid value at the call previous to the current recursion and thus are independent.
Conclusion, still have to insist the 1st implementation although idea differs


# (2) indep
Ajacent boxes with same color must be removed together to maximize the result. We can remove them as we reach them or remove them after removing certain other boxes in the middle. The former return an immediate result, the latter entails the possibility that the adjacent same boxes will further increase length.

Moreover, boxes in the last removal should be all of the same color. Thus, taking the following testcase as an example, we start with 4, assuming it to be the color of the last removed box(es). If only the adjacent two 4 are still presented in the last removal, we count it and traceback recursively to find the max contribution of the rest elements.

If box 4 in loc 8 is also presented with the first two, then all elements in middle must have been removed some time. We thus count this. Then, we also check the rest elements.

Moreover, it is also possible that only box 4 in Loc 0, 1 and 11 are presented in the last removal. We do a recursion for elements from 2 to 10 in this case. Notably, the case where box 4 in 0, 1, 4, and 11 are all presented in last removal is already counted in the recursion from element 5 onward in case of the presence of 0,1,4 in the last removal.

Then, we may also assume that box 3 is the last removed. However, as this indicates the removal of box 4 in 0 and 1, and as we have already figured out max(0,1) + max(2,n-1) this is regarded as repetition.

id   0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
ele  4 4 3 3 2 2 2 3 4 6  5  4  3  2  2  1
 |
shrink
 |
      0 1 2 3 4 5 6 7 8 
count 2 2 3 1 1 1 1 1 2
ele   4 3 2 3 4 6 5 3 2


# (1) CITED
Since the input is an array, let's begin with the usual approach by breaking it down with the original problem applied to each of the subarrays. Let the input array be boxes with length n. Define T(i, j) as the maximum points one 
can get by removing boxes of the subarray boxes[i, j] (both inclusive). The original problem is identified as T(0, n - 1) and the termination condition is as follows:

(a) T(i, i - 1) = 0: no boxes so no points.
(b) T(i, i) = 1: only one box left so the maximum point is 1.

Next let's try to work out the recurrence relation for T(i, j). Take the first box boxes[i](i.e., the box at index i) as an example. What are the possible ways of removing it? (Note: we can also look at the last box and the analyses turn out to be the same.)

If it happens to have a color that you dislike, you'll probably say "I don't like this box so let's get rid of it now". In this case, you will first get 1 point for removing this poor box. But still you want maximum points for the remaining boxes, which by definition is T(i + 1, j). In total your points will be 1 + T(i + 1, j). But later after reading the rules more carefully, you realize that you might get more points if this box (boxes[i]) can be removed together with other boxes of the
same color. For example, if there are two such boxes, you get 4 points by removing them simultaneously, instead of 2 by removing them one by one. So you decide to let it stick around a little bit longer until another box of the same color (whose index is m) becomes its neighbor. Note up to this moment all boxes from index i + 1 to index m - 1 would have been removed. So if we again aim for maximum points, the points gathered so far will be T(i + 1, m - 1). What about the remaining boxes?

At this moment, the boxes we left behind consist of two parts: the one at index i (boxes[i]) and those of the subarray boxes[m, j], with the former bordering the latter from the left. Apparently there is no way applying the definition of the 
subproblem to the subarray boxes[m, j], since we have some extra piece of information that is not included in the definition. In this case, I shall call that the definition of the subproblem is not self-contained and its solution relies on information external to the subproblem itself.

Another example of problem that does not have self-contained subproblems is leetcode 312. Burst Balloons, where the maximum coins of subarray nums[i, j] depend on the two numbers adjacent to nums[i] on the left and to nums[j] on the right. So you may find some similarities between these two problems.

Problems without self-contained subproblems usually don't have well-defined recurrence relations, which renders it impossible to be solved recursively. The cure to this issue can sound simple and straightforward: modify the definition of the problem to absorb the external information so that the new one is self-contained.

So let's see how we can redefine T(i, j) to make it self-contained. First let's identify the external information. On the one hand, from the point of view of the subarray boxes[m, j], it knows nothing about the number (denoted by k) of boxes of the same color as boxes[m]to its left. On the other hand, given this number k, the maximum points can be obtained from removing all these boxes is fixed. Therefore the external information to T(i, j) is this k. Next let's absorb this extra piece of information into the definition of T(i, j) and redefine it as T(i, j, k) which denotes the maximum points possible by removing the boxes of subarray boxes[i, j] with k boxes attached to its left of the same color as boxes[i]. Lastly
let's reexamine some of the statements above:

Our original problem now becomes T(0, n - 1, 0), since there is no boxes attached to the left of the input array at the beginning. The termination conditions now will be: 
(a) T(i, i - 1, k) = 0: no boxes so no points, and this is true for any k (you can interpret it as nowhere to attach the boxes).
(b) T(i, i, k) = (k + 1) * (k + 1): only one box left in the subarray but we've already got k  boxes of the same color attached to its left, so the total number of boxes of the same color is (k + 1) and the maximum point is (k + 1) * (k + 1).

The recurrence relation is as follows and the maximum points will be the larger of the two cases:
(a) If we remove boxes[i] first, we get (k + 1) * (k + 1) + T(i + 1, j, 0) points, where for the first term, instead of 1 we again get (k + 1) * (k + 1) points for removing boxes[i] due to the attached boxes to its left; and for the second term there will be no attached boxes so we have the 0 in this term.
(b) If we decide to attach boxes[i] to some other box of the same color, say boxes[m], then from our analyses above, the total points will be T(i + 1, m - 1, 0) + T(m, j, k + 1), where for the first term, since there is no attached boxes for subarray boxes[i + 1, m - 1], we have k = 0 for this part; while for the second term, the total number of attached boxes for subarray boxes[m, j] will increase by 1 because apart from the original k boxes, we have to account for boxes[i]now, so we have k + 1 for this term. But we are not done yet. What if there are multiple boxes of the same color as boxes[i] within subarray boxes[i + 1, j]? We have to try each of them and choose the one that yields the maximum points. Therefore the final answer for this case will be: max(T(i + 1, m - 1, 0) + T(m, j, k + 1)) where i < m <= j && boxes[i] == boxes[m].

Before we get to the actual code, it's not hard to discover that there is overlapping among the subproblems T(i, j, k), therefore it's qualified as a DP problem and its intermediate results should be cached for future lookup. Here each subproblem is characterized by three integers (i, j, k), all of which are bounded, i.e, 0 <= i, j, k < n, so a three-dimensional array (n x n x n) will be good enough for the cache.

Finally here are the two solutions, one for top-down DP and the other for bottom-up DP. From the bottom-up solution, the time complexity will be O(n^4) and the space complexity will be O(n^3).



## Testcases
[1,2,1]
[5, 9, 6, 5, 6, 9, 6, 9, 5]
[3, 8, 8, 5, 5, 3, 9, 2, 4, 4, 6, 5, 6, 9, 6, 2, 8, 6, 4, 1, 9, 5, 3, 10]
[3, 8, 8, 5, 5, 3, 9, 2, 4, 4, 6, 5, 8, 4, 8, 6, 9, 6, 2, 8, 6, 4, 1, 9, 5, 3, 10, 5, 3, 3  , 9, 8, 8, 6, 5, 3, 7, 4,   9, 6, 3, 9, 4, 3, 5, 10, 7, 6, 10, 7]
[4,4,3,3,2,2,2,3,4,6,5,4,3,2,2,1]
[1,1,1,1,1,1,1,1,1,1,2,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]


## Codes
# 2nd visit_Mar_10_2019
// DP_top-down_imple bugs
class Solution {
    
    int[][][] dp;
    ArrayList<Integer> ele, count;
    
    private int solve(int lo, int hi, int k, int mid) {
        if (lo > hi) return 0;
        if (dp[lo][hi][k] != 0) return dp[lo][hi][k];
        int cl = k + count.get(lo);
        int cur = mid + cl*cl + solve(lo+1, hi, 0, 0); // remove immediately
        for (int i = lo + 1; i <= hi; i++) {
            if (ele.get(i) != ele.get(lo)) continue;
            int newMid = mid + solve(lo + 1, i - 1, 0, 0);
            cur = Math.max(cur, solve(i, hi, cl, newMid));
        }
        dp[lo][hi][k] = cur;
        return cur;
    }
    
    public int removeBoxes(int[] boxes) {
        int n = boxes.length, maxCount = 0, m = 0;
        ele = new ArrayList<Integer>(); count = new ArrayList<Integer>();
        for (int j = 1, i = 0; j <= n; j++) {
            if (j != n && boxes[i] == boxes[j]) continue;
            ele.add(boxes[j-1]); count.add(j-i); 
            maxCount = Math.max(maxCount, j-i);
            i = j; m++;
        }
        dp = new int[m][m][n];
        return solve(0, m - 1, 0, 0);
    }
}

# 1st attempt
// (2) DP_top-down
class Solution {
    
    int[][][] dp;
    LinkedList<Integer> count;
    LinkedList<Integer> ele;
    
    private int solve(int i, int j, int len) {
        if (i > j) return 0;
        if (dp[i][j][len] != 0) return dp[i][j][len];
        int curLen = len + count.get(i);
        int max = curLen*curLen + solve(i + 1, j, 0); // remove immediately
        for (int next = i + 1; next <= j; next++) {   // suspend until next same color
            if (ele.get(next) != ele.get(i)) continue;
            int middle = solve(i+1, next-1, 0);
            int last = solve(next, j, curLen);
            max = Math.max(max, middle + last);
        }
        dp[i][j][len] = max;
        return max;
    }
    
    public int removeBoxes(int[] boxes) {
        int n = boxes.length, i = 0, j = 0;
        count = new LinkedList<Integer>();
        ele = new LinkedList<Integer>();
        while (i < n) {
            while (i + 1 < n && boxes[i] == boxes[i+1]) i++;
            count.add(++i -j);
            ele.add(boxes[j]);
            j = i;
        }
        int m = count.size();
        dp = new int[m][m][n];
        return solve(0, m-1, 0);
        //return count.get(0);
    }
}

// cpp
class Solution {
public:
    int removeBoxes(vector<int>& boxes) {     
       
        vector<int> A, f; // f: frequency
        for(int i=1,count=1; i<=boxes.size(); ++i){
            if(boxes[i] != boxes[i - 1]||i==boxes.size()) 
                A.push_back(boxes[i-1]), f.push_back(count),count=1;
            else count++;        
        }
        
 
        int dp[100][100][100] = {0};
   
        function<int(int, int , int)> dfs =[&](int i, int j, int k){           
            if (i > j) return 0; 
             if (dp[i][j][k]) return dp[i][j][k];
            dp[i][j][k] = dfs(i, j - 1, 0) + (f[j] + k) * (f[j] + k);
            for (int pos = i; pos < j; pos++) {
                if (A[pos] == A[j]) dp[i][j][k] = max(dp[i][j][k], dfs(i, pos, f[j] + k) + dfs(pos + 1, j - 1, 0));
            }
            return dp[i][j][k]; 
        };
  
        return dfs(0, A.size()-1, 0);
    }
};

// (1) DP_bottom-up
class Solution {
    
    public int removeBoxes(int[] boxes) {
        int n = boxes.length, i = 0, j = 0;
        List<Integer>count = new ArrayList<Integer>(), ele = new ArrayList<Integer>();
        while (i < n) {
            while (i + 1 < n && boxes[i] == boxes[i+1]) i++;
            count.add(++i -j);
            ele.add(boxes[j]);
            j = i;
        }
        int m = count.size();
        
        int[][][] dp = new int[m][m][n];
        
        // subarray starts from j, ends at j with rep-many same boxes remained
        for (j = 0; j < m; j++) for(int rep = 0; rep < j; rep++) 
                dp[j][j][rep] = (rep+count.get(j))*(rep+count.get(j));
        // bottom up dp
        for (int len = 1; len < m; len++) { // dist between j and i
            for (i = len; i < m; i++) {     // subarray ends at i
                j = i - len;                //          starts from j
                dp[j][i][0] = dp[j][j][0] + dp[j+1][i][0];
                for (int rep = 0; rep <= j; rep++) {
                    for (int c = j + 1; c <= i; c++) { // c between j and i, same as j
                        if (ele.get(j) != ele.get(c)) continue;
                        int curRep = rep + count.get(c);
                        int immed = dp[j+1][c-1][0] + curRep*curRep + dp[c+1][i][0];
                        int delay = dp[j+1][c-1][0] + dp[c][i][rep];
                        dp[j][i][rep] = Math.max(dp[j][i][rep], Math.max(immed, delay));
                    }
                }
            }
        }
        return dp[0][m-1][0];
    }
}
